# 多輸出布林函數最小化工具 - 專案報告書

## 摘要

本專案旨在開發一個功能完整且實用的多輸出布林函數最小化工具。傳統邏輯設計課程中的作業需求，通常僅要求處理質蘊涵項 (Prime Implicants, PI)，但這忽略了在真實應用中極為重要的 ==Don't Care== 條件。為了建構一個更全面的工具，本專案不僅完整支援了 Don't Care 項的處理，更因此衍生出兩種核心輸入模式：==「PI 輸入模式」==與==「Minterms 輸入模式」==，以應對不同的使用情境。

本工具的核心演算法基於 Patrick Method，並針對多輸出函數的最佳化進行了擴展與創新。我們設計了一套 ==「聯合式 Patrick Method」== 演算法，此演算法將所有在 Quine-McCluskey 迭代過程中產生的==所有蘊涵項 (Implicants)==都視為候選 PI，以確保能找到成本最低的共享項組合。為了處理龐大的運算複雜度，我們導入了==成本剪枝 (Cost Pruning)==技術。此外，我們也提出了一套更貼近實際電路成本的==「三階段成本模型」==，克服了傳統 Patrick Method 在多輸出共享成本計算上的限制。

系統前端採用 HTML、CSS 與 JavaScript 技術，並利用 PWA (Progressive Web App) 技術實現了跨平台部署，讓使用者無論在桌面或行動裝置上都能獲得流暢的操作體驗。

---
## 1. 專案動機與目標

### 1.1 原始需求與挑戰

最初的作業需求是基於已知的 Prime Implicants (PIs) 集合，來找出布林函數的最小化 SOP (Sum of Products) 形式。對於多輸出問題，則需考慮可能的共享項 (Shared Terms)。

然而，這個需求存在一個理論上的盲點：**它無法妥善處理 ==Don't Care 項==**。Don't Care 項在邏輯化簡中扮演著關鍵角色，它們可以與 Minterms 組合，生成更簡潔的質蘊涵項。若要支援 Don't Care，系統就必須知道原始函數的 Minterms 是哪些。

### 1.2 衍生問題與解決方案

既然處理 Don't Care 必須提供 Minterms，那麼從「使用者輸入 PI」開始化簡就顯得不夠直觀且繁瑣。一個優秀的工具應該能直接從最原始的函數定義（即 Minterms）開始分析。

為了解決此問題，並兼顧不同使用者的需求，我們設計了兩種輸入模式：

1.  **Minterms 輸入模式**：使用者直接輸入各函數的 Minterms 與 Don't Cares。系統會自動執行 Quine-McCluskey 演算法生成所有必要的蘊涵項，再進行後續的 Patrick Method 最佳化。這是最完整、最自動化的模式。
2.  **Prime Implicants (PI) 輸入模式**：保留給進階使用者或特定情境。使用者自行提供所有候選的 PI，並定義各函數由哪些 Minterms 組成。此模式下，系統會基於使用者提供的 PI 進行共享最佳化。

這個雙模式設計，使得本工具不僅符合原始作業需求，更擴展成一個功能更強大、更貼近實際應用的邏輯設計輔助系統。

---
## 2. 核心演算法設計

本專案的核心是兩套針對不同情境設計的 Patrick Method 演算法。

### 2.1 單函數輸出模式：標準 Patrick Method

當系統檢測到只有一個輸出函數時，會採用最經典的演算法流程：

1.  **生成真正的 PI**：使用 `generateOnlyTruePrimeImplicants` 函數，透過 Quine-McCluskey 演算法找出所有 ==真正的 Prime Implicants==。此過程只保留最終無法再被合併的項。
2.  **建立覆蓋表 (Coverage Table)**：分析每個 Minterm 被哪些 PI 所覆蓋。
3.  **尋找必要 PI (Essential PIs)**：找出那些唯一覆蓋了某個 Minterm 的 PI。這些是最終解的必要組成部分。
4.  **求解最小覆蓋**：對於被必要 PI 覆蓋後剩餘的 Minterms，使用 Patrick Method 找出成本最低的 PI 組合來完成覆蓋。
5.  **組合最終解**：將必要 PI 與最小覆蓋解組合，得到最終的最小化 SOP。

### 2.2 多函數輸出模式：創新的聯合式 Patrick Method

多輸出問題的複雜之處在於，==成本最低的共享項，不一定是單一函數的質蘊涵項 (Prime Implicant)==。它可能是一個在合併過程中產生的中間蘊涵項 (Implicant)。

為了找到全域最佳解，我們設計了一套創新的「聯合式 Patrick Method」，其底層邏輯如下：

1.  **生成所有蘊涵項 (Implicants)**：
    - 對於每個函數，我們使用 Quine-McCluskey 演算法，但關鍵在於 **我們保留所有迭代過程中產生的蘊涵項，無論其是否為最終的 PI**。例如，對於 Minterms $m_0(0000)$ 和 $m_1(0001)$，我們會將 `0000`、`0001` 和它們合併後的 `000-` ==都視為候選 PI==。
    - 這個步驟確保了所有可能的共享項都被納入候選清單，從而避免錯失最佳解。

2.  **合併與標記所有候選 PI**：
    - 將所有函數生成的所有蘊涵項合併成一個全域列表，並移除重複項。
    - 為每個唯一的蘊涵項標記它來自哪些函數 (例如，`用於: F1, F2`) 並計算其基礎成本。

3.  **建立大型聯合 Patrick Method 表達式**：
    - 我們將所有函數的所有 Minterms 視為一個大的覆蓋問題。每個待覆蓋項都帶有其所屬函數的標籤，例如 $F_1\text{-}m_1$ 和 $F_2\text{-}m_1$ 被視為兩個獨立的目標。
    - 最終的 Patrick 表達式是所有這些待覆蓋項的邏輯與 (AND) 組合，其通用形式為：
    $$
    P = \prod_{f \in \text{Functions}} \prod_{m \in \text{Minterms}(f)} \left( \sum_{pi \in \text{Covers}(f\text{-}m)} pi \right)
    $$
    - 舉例來說，對於 $F_1 = \Sigma m(1,5)$ 和 $F_2 = \Sigma m(0,1)$，其表達式會是：
    $(PI_a + PI_b) \cdot (PI_c) \cdot (PI_d) \cdot (PI_a + PI_e)$
    其中 $(PI_a + PI_b)$ 是覆蓋 $F_1\text{-}m_1$ 的項，$(PI_c)$ 覆蓋 $F_1\text{-}m_5$，$(PI_d)$ 覆蓋 $F_2\text{-}m_0$，而 $(PI_a + PI_e)$ 覆蓋 $F_2\text{-}m_1$。

4.  **求解與剪枝 (Pruning)**：
    - 理論上，需要將上述大型表達式完全展開為 SOP 形式，然後找到成本最低的積項 (Product Term)。但這在計算上是不可行的。
    - 因此，我們採用了 ==成本剪枝的回溯搜索算法==。在遞迴搜索解的過程中，如果當前組合的成本已經超過已知的最小成本，則提前中止這條搜索路徑，大幅減少了無效的計算。這正是「動態限制」的實現。

5.  **分解最終解**：
    - 從成本最低的解中（例如 $PI_1 \cdot PI_{13} \cdot PI_{20} \cdot \dots$），我們可以為每個函數構建其最終表達式。
    - 如果最佳解包含 $PI_1$，而 $PI_1$ 同時用於 $F_1$ 和 $F_2$，那麼 $F_1$ 和 $F_2$ 的最終表達式中都會包含 $PI_1$ 對應的項。
    $$
    F_1= PI_1 + PI_{13} + PI_{20} + PI_{21} \\
    F_2= PI_1 + PI_{30} + PI_{31}
    $$

---
## 3. 創新成本模型：三階段成本計算

傳統的 Patrick Method 在數學上將 $P*P$ 視為 $P$，這在布林代數中是正確的。但在實際電路設計中，一個項若被多個函數共享，其總成本並非單純的一個項的成本，因為需要額外的邏輯閘輸入。

我們提出的成本模型更貼近硬體實現： ==`共享成本 = 基礎成本 + (使用次數 - 1)`==。例如，一個成本為 3 的項 $P$，若被 2 個函數共享，其總貢獻成本為 $3 + (2-1) = 4$。

為了實現這個精確的成本計算，我們設計了「三階段成本計算」流程，此流程在聯合式 Patrick Method 的剪枝判斷中扮演關鍵角色：

#### 第一階段：PI 選擇成本 (Stage 1 Cost)
- **定義**：一個候選解中所有 PI 的原始成本總和。
- **作用**：這是最基礎的成本估算，用於==第一層快速剪枝==，能過濾掉大量明顯不佳的組合。

#### 第二階段：函數內冗餘移除 (Stage 2 Optimization)
- **定義**：在一個候選解（一組 PI）被選定後，對 **每個函數單獨** 進行最佳化，移除其內部多餘的覆蓋。
- **作用**：`removeRedundantPIsForStage2` 函數會確定每個 PI 實際被哪些函數所 **必要** 使用。例如，如果組合中同時有 $y$ 和 $x'y$，且它們都用於覆蓋函數 $F_1$，那麼 $x'y$ 對於 $F_1$ 來說就是多餘的，因為 $y$ 已經完全覆蓋了它。此階段是實現精確共享成本計算的基礎。

#### 第三階段：真實共享成本計算 (Stage 3 Cost)
- **定義**：在第二階段完成後，統計每個 PI **實際被使用** 的次數，並套用我們的共享成本公式。
- **作用**：計算出這個候選解的 ==真實總成本==。這個最終成本是決定最佳解的最終依據，也是剪枝算法中最重要的判斷標準。

#### 成本計算範例：
| 項目 | 基礎成本 | 假設使用次數 | 共享成本計算公式 | 最終成本 |
| :--- | :--- | :--- | :--- | :--- |
| `$x'z'$` | 3 | 2 | `$3 + (2-1)$` | 4 |
| `$y$` | 1 | 6 | `$1 + (6-1)$` | 6 |
| `$xy'` | 3 | 1 | `$3 + (1-1)$` | 3 |

---
## 4. 系統實作與技術棧

### 4.1 技術選擇

- **前端框架**: ==純 HTML、CSS、JavaScript==。
- **核心優勢**:
    - **跨平台相容**: 無需任何編譯或環境配置，直接在所有現代瀏覽器中運行。
    - **易於部署**: 只需將靜態檔案部署到任何網頁伺服器即可。
    - **PWA (Progressive Web App)**: 透過 `manifest.json` 和 `Service Worker (sw.js)` 的配置，本工具可以被「安裝」到使用者的桌面或手機主畫面上，提供離線可用、類似原生 App 的體驗。

### 4.2 使用者介面 (UI) 與體驗 (UX)

- **響應式設計**: UI 能自動適應不同尺寸的螢幕，從大尺寸桌面顯示器到小型手機螢幕都能提供良好的操作體驗。
- **動態輸入介面**: 無論是 PI 模式還是 Minterms 模式，使用者都可以動態新增或刪除函數，操作直觀方便。
- **即時回饋**:
    - PI 模式下，每個函數的 PI 數量會即時更新。
    - 執行運算時，會顯示載入動畫，避免使用者以為頁面當機。
- **輔助功能**:
    - ==自動生成函數定義==: 在 PI 模式下，使用者輸入完各函數的 PI 後，可一鍵自動計算並生成對應的 Minterms 定義，極大提升了便利性。
    - **分享與複製**: 方便使用者將結果分享給他人或複製到報告中。

---
## 5. 結論

本專案成功地從一個基礎的課程作業需求出發，透過對問題本質的深入思考，擴展成一個功能強大、理論扎實且介面友好的多輸出布林函數最小化工具。

我們的核心貢獻包含：

1.  ==雙模式輸入系統==，兼顧了理論完整性與使用便利性。
2.  創新的==「聯合式 Patrick Method」==，透過納入所有蘊涵項並結合成本剪枝，有效解決了多輸出函數的全域最佳化問題。
3.  精確的==「三階段成本模型」==，使最佳化結果更貼近真實的電路實現成本。
4.  現代化的== PWA 技術應用==，提供了卓越的跨平台使用體驗。

最終，本專案不僅是一個滿足需求的程式，更是一個將理論知識與工程實踐緊密結合的完整解決方案。

# 自創的聯合式Patrick Method 底層邏輯-示範
F1 = Σm(1,5,7,8,10,11,12,14,15)
生成的PIs:
  F1-PI1: 0001 → W'X'Y'Z (覆蓋: m1)
  F1-PI2: 0101 → W'XY'Z (覆蓋: m5)
  F1-PI3: 0111 → W'XYZ (覆蓋: m7)
  F1-PI4: 1000 → WX'Y'Z' (覆蓋: m8)
  F1-PI5: 1010 → WX'YZ' (覆蓋: m10)
  F1-PI6: 1011 → WX'YZ (覆蓋: m11)
  F1-PI7: 1100 → WXY'Z' (覆蓋: m12)
  F1-PI8: 1110 → WXYZ' (覆蓋: m14)
  F1-PI9: 1111 → WXYZ (覆蓋: m15)
  F1-PI10: 0-01 → W'Y'Z (覆蓋: m1,m5)
  F1-PI11: 10-0 → WX'Z' (覆蓋: m8,m10)
  F1-PI12: 1-00 → WY'Z' (覆蓋: m8,m12)
  F1-PI13: 01-1 → W'XZ (覆蓋: m5,m7)
  F1-PI14: 101- → WX'Y (覆蓋: m10,m11)
  F1-PI15: 1-10 → WYZ' (覆蓋: m10,m14)
  F1-PI16: 11-0 → WXZ' (覆蓋: m12,m14)
  F1-PI17: -111 → XYZ (覆蓋: m7,m15)
  F1-PI18: 1-11 → WYZ (覆蓋: m11,m15)
  F1-PI19: 111- → WXY (覆蓋: m14,m15)
  F1-PI20: 1--0 → WZ' (覆蓋: m10,m12,m14,m8)
  F1-PI21: 1-1- → WY (覆蓋: m10,m11,m14,m15)

F2 = Σm(0,1,4,6,7,8,12)
生成的PIs:
  F2-PI1: 0000 → W'X'Y'Z' (覆蓋: m0)
  F2-PI2: 0001 → W'X'Y'Z (覆蓋: m1)
  F2-PI3: 0100 → W'XY'Z' (覆蓋: m4)
  F2-PI4: 0110 → W'XYZ' (覆蓋: m6)
  F2-PI5: 0111 → W'XYZ (覆蓋: m7)
  F2-PI6: 1000 → WX'Y'Z' (覆蓋: m8)
  F2-PI7: 1100 → WXY'Z' (覆蓋: m12)
  F2-PI8: 000- → W'X'Y' (覆蓋: m0,m1)
  F2-PI9: 0-00 → W'Y'Z' (覆蓋: m0,m4)
  F2-PI10: -000 → X'Y'Z' (覆蓋: m0,m8)
  F2-PI11: 01-0 → W'XZ' (覆蓋: m4,m6)
  F2-PI12: -100 → XY'Z' (覆蓋: m4,m12)
  F2-PI13: 1-00 → WY'Z' (覆蓋: m8,m12)
  F2-PI14: 011- → W'XY (覆蓋: m6,m7)
  F2-PI15: --00 → Y'Z' (覆蓋: m0,m12,m4,m8)

PI的生成，無論有無跌代都需要視為PI，例如
m0,m1
0000
0001
000-
所有都視為PI

合併所有PI並去重
PI1: 0001 → W'X'Y'Z (用於: F1, F2, 成本: 5)
PI2: 0101 → W'XY'Z (用於: F1, 成本: 5)
PI3: 0111 → W'XYZ (用於: F1, F2, 成本: 5)
PI4: 1000 → WX'Y'Z' (用於: F1, F2, 成本: 5)
PI5: 1010 → WX'YZ' (用於: F1, 成本: 5)
PI6: 1011 → WX'YZ (用於: F1, 成本: 5)
PI7: 1100 → WXY'Z' (用於: F1, F2, 成本: 5)
PI8: 1110 → WXYZ' (用於: F1, 成本: 5)
PI9: 1111 → WXYZ (用於: F1, 成本: 5)
PI10: 0-01 → W'Y'Z (用於: F1, 成本: 4)
PI11: 10-0 → WX'Z' (用於: F1, 成本: 4)
PI12: 1-00 → WY'Z' (用於: F1, F2, 成本: 4)
PI13: 01-1 → W'XZ (用於: F1, 成本: 4)
PI14: 101- → WX'Y (用於: F1, 成本: 4)
PI15: 1-10 → WYZ' (用於: F1, 成本: 4)
PI16: 11-0 → WXZ' (用於: F1, 成本: 4)
PI17: -111 → XYZ (用於: F1, 成本: 4)
PI18: 1-11 → WYZ (用於: F1, 成本: 4)
PI19: 111- → WXY (用於: F1, 成本: 4)
PI20: 1--0 → WZ' (用於: F1, 成本: 3)
PI21: 1-1- → WY (用於: F1, 成本: 3)
PI22: 0000 → W'X'Y'Z' (用於: F2, 成本: 5)
PI23: 0100 → W'XY'Z' (用於: F2, 成本: 5)
PI24: 0110 → W'XYZ' (用於: F2, 成本: 5)
PI25: 000- → W'X'Y' (用於: F2, 成本: 4)
PI26: 0-00 → W'Y'Z' (用於: F2, 成本: 4)
PI27: -000 → X'Y'Z' (用於: F2, 成本: 4)
PI28: 01-0 → W'XZ' (用於: F2, 成本: 4)
PI29: -100 → XY'Z' (用於: F2, 成本: 4)
PI30: 011- → W'XY (用於: F2, 成本: 4)
PI31: --00 → Y'Z' (用於: F2, 成本: 3)

最小成本計算方式使用大型聯合Patrick Method，一次計算所有函數的Patrick Method
F1 = Σm(1,5,7,8,10,11,12,14,15)
F2 = Σm(0,1,4,6,7,8,12)

(F1-m1) * (F1-m5) * (F1-m7)... * (F1-m15) * (F2-m0) * (F2-m1)... * (F2-m12)
=> (PI1+PI10+PI25) * ... * (PI7+PI12+PI16+PI20+PI29+PI31)

全部乘開成本最小的就是
PI1 * PI13 * PI20 * PI21 * PI30 * PI31
5+4+3+3+4+3=22
(==這裡是三階段成本的第一階段==)

PI1: 0001 → W'X'Y'Z (用於: F1, F2, 成本: 5)
PI13: 01-1 → W'XZ (用於: F1, 成本: 4)
PI20: 1--0 → WZ' (用於: F1, 成本: 3)
PI21: 1-1- → WY (用於: F1, 成本: 3)
PI30: 011- → W'XY (用於: F2, 成本: 4)
PI31: --00 → Y'Z' (用於: F2, 成本: 3)

所以
F1=PI1 + PI13 + PI20 + PI21
F2=PI1 + PI30 + PI31

F1= W'X'Y'Z + W'XZ  + WZ' + WY
F2= W'X'Y'Z  + W'XY + Y'Z'

# 三階段成本計算-示範
x,y,z
F1 = Σm(0,2,5,6,7)
F2 = Σm(2,3,5,6,7)
F3 = Σm(0,2,3,4,5)

這個答案有兩組解，我只示範其中一種
第一階段找到這6個PI：-1-, -10, 0-0, 01-, 1-1, 10-
-1- 覆蓋：F2             (y)=m2,m3,m6,m7
-10 覆蓋：F1、F2     (yz')=m2,m6
0-0 覆蓋：F1、F3     (x'z')=m0,m2
01- 覆蓋：F2、F3     (x'y)=m2,m3
1-1 覆蓋：F1、F2    (xz)=m5,m7
10- 覆蓋：F3           (xy')=m4,m5

F1 = x'z' + xz + yz'  
F2 = y + xz + x'y + yz'
F3 = x'z' + x'y + xy'  
使用的PI: -1-, -10, 0-0, 01-, 1-1, 10-
這裡在Patrick Method上的成本應該是長這樣 $P1*P2*P3*P4*P5*P6$ 所以只算到這六個個別的成本相加為 $(1+3+3+3+3+3)=16$
但實際上的當前成本是 $16+(總term數量-PI數量)=16+((3+4+3)-6)=20$
但20還是不對因為 y + xz + x'y + yz' 與 y + xz 兩者算式覆蓋範圍一模一樣，所以成本可以更小 

第二階段刪除冗餘PI移除
F1 = x'z' + xz + yz'  
F2 = y + xz  
F3 = x'z' + x'y + xy'  
使用的PI: -1-, -10, 0-0, 01-, 1-1, 10-

最後第三階段
再次計算刪除冗餘後的成本$16+(總term數量-PI數量)=16+((3+2+3)-6)=18$
最後才是成本18