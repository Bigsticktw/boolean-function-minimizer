<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <!-- 基本網頁設定 -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>多輸出布林函數最小化工具</title>
    
    <!-- PWA 支援設定 -->
    <meta name="theme-color" content="#2c3e50">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="多輸出最小化工具">
    
    <!-- SEO 和網頁資訊設定 -->
    <meta name="description" content="專業的多輸出布林函數最小化工具，支援 Patrick Method 演算法">
    <meta name="keywords" content="Patrick Method, 邏輯最小化, 布爾代數, SOP, Prime Implicants, 多輸出">
    <meta name="author" content="Logic Circuit Final Project">
    
    <!-- PWA 應用程式設定 -->
    <link rel="manifest" href="manifest.json">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="application-name" content="Boolean Minimizer">
    <meta name="apple-mobile-web-app-title" content="Boolean Minimizer">
    <meta name="msapplication-starturl" content="./index.html">
    <link rel="icon" sizes="192x192" href="icon-192.png">
    <link rel="apple-touch-icon" sizes="192x192" href="icon-192.png">
    
    <style>
        /* 全域樣式重置 */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        /* 主體樣式設定 */
        body {
            font-family: 'Microsoft JhengHei', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 20px 40px rgba(0,0,0,0.15);
        }
        
        .header {
            background: linear-gradient(135deg, #2c3e50, #34495e);
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }
        
        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }
        
        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0;
            min-height: 600px;
        }
        
        .input-section {
            padding: 30px;
            background: #f8f9fa;
            border-right: 1px solid #dee2e6;
        }
        
        .output-section {
            padding: 30px;
            background: white;
        }
        
        .section-title {
            font-size: 1.5em;
            color: #2c3e50;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 3px solid #74b9ff;
        }
        
        .form-group {
            margin-bottom: 25px;
        }
        
        .form-label {
            display: block;
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 8px;
            font-size: 1.1em;
        }
        
        .input-mode-selector {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .radio-group {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 12px 20px;
            background: white;
            border: 2px solid #ddd;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .radio-group:hover {
            border-color: #74b9ff;
            background: #f1f8ff;
        }
        
        .radio-group input[type="radio"]:checked {
            accent-color: #74b9ff;
        }
        
        .radio-group input[type="radio"]:checked + .radio-label {
            color: #74b9ff;
            font-weight: bold;
        }
        
        .input-field {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 1em;
            font-family: 'Courier New', monospace;
            transition: border-color 0.3s ease;
        }
        
        .input-field:focus {
            outline: none;
            border-color: #74b9ff;
            box-shadow: 0 0 0 3px rgba(116, 185, 255, 0.1);
        }
        
        .variable-input {
            display: grid;
            grid-template-columns: 1fr 100px;
            gap: 10px;
            align-items: end;
        }
        
        .btn {
            padding: 15px 30px;
            border: none;
            border-radius: 8px;
            font-size: 1.1em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #74b9ff, #0984e3);
            color: white;
            width: 100%;
            margin: 20px 0;
        }
        
        .btn-primary:hover {
            background: linear-gradient(135deg, #0984e3, #0770d1);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        
        .btn-secondary {
            background: #6c757d;
            color: white;
            margin-right: 10px;
            font-size: 0.9em;
            padding: 10px 20px;
            text-transform: none;
            letter-spacing: normal;
        }
        
        .btn-secondary:hover {
            background: #545b62;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(108, 117, 125, 0.3);
        }
        
        .button-group {
            margin: 20px 0;
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .button-group .btn {
            flex: 1;
            min-width: 140px;
        }
        
        .button-group .btn-primary {
            margin: 0;
            width: auto;
        }
        
        .btn-info {
            background: #17a2b8;
            color: white;
            margin-right: 10px;
            font-size: 0.9em;
            padding: 10px 20px;
            text-transform: none;
            letter-spacing: normal;
        }
        
        .btn-info:hover {
            background: #138496;
            transform: translateY(-1px);
        }
        
        .btn-add {
            background: #28a745;
            color: white;
            font-size: 0.9em;
            padding: 10px 20px;
            text-transform: none;
            letter-spacing: normal;
        }
        
        .btn-add:hover {
            background: #218838;
        }
        
        .btn-remove {
            background: #dc3545;
            color: white;
            font-size: 0.8em;
            padding: 6px 12px;
            text-transform: none;
            letter-spacing: normal;
        }
        
        .btn-remove:hover {
            background: #c82333;
        }
        
        /* 函數動態輸入框樣式 */
        .function-input-row {
            display: flex;
            flex-direction: column;
            margin-bottom: 15px;
            padding: 15px;
            background: white;
            border-radius: 8px;
            border-left: 4px solid #007bff;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .function-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 10px;
        }
        
        .function-label {
            font-weight: bold;
            color: #495057;
            font-size: 16px;
        }
        
        .function-inputs {
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .function-input-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .function-input {
            padding: 8px 12px;
            border: 2px solid #e9ecef;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            transition: border-color 0.3s ease;
            min-width: 120px;
        }
        
                    .function-input:focus {
                outline: none;
                border-color: #007bff;
                box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);
            }
            
            textarea:focus {
                outline: none;
                border-color: #007bff !important;
                box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);
            }
        
        .function-input-label {
            font-size: 14px;
            color: #495057;
            white-space: nowrap;
            font-weight: 500;
        }
        
        /* PI 動態輸入框樣式 */
        .function-pi-group {
            background: white;
            border-radius: 8px;
            margin-bottom: 15px;
            border-left: 4px solid #28a745;
            overflow: hidden;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .function-pi-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 15px;
            background: #e9ecef;
            border-bottom: 1px solid #dee2e6;
        }
        
        .function-pi-title {
            margin: 0;
            font-size: 16px;
            color: #495057;
            cursor: pointer;
            user-select: none;
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: bold;
        }
        
        .function-pi-title:hover {
            color: #007bff;
        }
        
        .function-pi-indicator {
            color: #6c757d;
            font-size: 12px;
            transition: color 0.3s ease;
        }
        
        .function-pi-indicator.active {
            color: #28a745;
        }
        
        .function-pi-inputs {
            padding: 15px;
        }
        
        .pi-input-row {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            gap: 10px;
        }
        
        .pi-label {
            font-weight: bold;
            color: #495057;
            min-width: 50px;
            font-size: 14px;
        }
        
        .pi-input {
            flex: 1;
            padding: 8px 12px;
            border: 2px solid #e9ecef;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            transition: border-color 0.3s ease;
        }
        
        .pi-input:focus {
            outline: none;
            border-color: #007bff;
            box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);
        }
        
        .result-area {
            min-height: 300px;
            background: #f8f9fa;
            border: 2px dashed #dee2e6;
            border-radius: 8px;
            padding: 20px;
            font-family: 'Courier New', monospace;
            font-size: 1em;
            overflow-y: auto;
            white-space: pre-wrap;
        }
        
        .result-area.has-content {
            background: white;
            border: 2px solid #28a745;
        }
        
        .loading {
            display: none;
            text-align: center;
            padding: 50px;
            color: #6c757d;
        }
        
        .loading.show {
            display: block;
        }
        
        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #74b9ff;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .example-section {
            background: #e8f4f8;
            border: 1px solid #b8daff;
            border-radius: 8px;
            padding: 15px;
            margin-top: 20px;
        }
        
        .example-title {
            font-weight: bold;
            color: #0c5460;
            margin-bottom: 10px;
        }
        
        .example-content {
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            color: #0c5460;
            line-height: 1.4;
        }
        
        /* 手機版響應式設計 */
        @media (max-width: 768px) {
            .container {
                margin: 10px;
                border-radius: 10px;
            }
            
            .header {
                padding: 20px 15px;
            }
            
            .header h1 {
                font-size: 1.8em;
                margin-bottom: 8px;
            }
            
            .header p {
                font-size: 0.95em;
            }
            
            .main-content {
                grid-template-columns: 1fr;
                min-height: auto;
            }
            
            .input-section, .output-section {
                padding: 20px 15px;
            }
            
            .input-section {
                border-right: none;
                border-bottom: 1px solid #dee2e6;
            }
            
            .section-title {
                font-size: 1.3em;
                margin-bottom: 15px;
            }
            
            .form-group {
                margin-bottom: 20px;
            }
            
            .input-mode-selector {
                flex-direction: column;
                gap: 10px;
            }
            
            .radio-group {
                padding: 10px 15px;
                font-size: 0.9em;
            }
            
            .variable-input {
                grid-template-columns: 1fr;
                gap: 10px;
            }
            
            .btn {
                padding: 12px 20px;
                font-size: 0.95em;
                letter-spacing: 0.5px;
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
            }
            
            .button-group {
                flex-direction: column;
                gap: 8px;
                margin: 15px 0;
            }
            
            .button-group .btn {
                flex: none;
                min-width: auto;
                width: 100%;
                margin: 0;
            }
            
            .btn-secondary {
                font-size: 0.85em;
                padding: 10px 15px;
                margin-right: 0;
            }
            
            .function-pi-header {
                padding: 10px 12px;
                flex-direction: column !important;
                gap: 8px;
                align-items: stretch !important;
                justify-content: flex-start !important;
            }
            
            .function-pi-title {
                font-size: 0.9em;
                flex: none !important;
                min-width: auto !important;
                width: 100% !important;
                text-align: left;
                margin-bottom: 8px;
            }
            
            .function-pi-header .btn-remove {
                width: 100% !important;
                margin: 0 !important;
                font-size: 0.8em;
                padding: 8px 12px;
                flex: none !important;
            }
            
            .function-pi-inputs {
                padding: 12px;
            }
            
            .pi-input-row {
                flex-direction: column !important;
                gap: 8px;
                margin-bottom: 12px;
                align-items: stretch !important;
            }
            
            .pi-label {
                min-width: auto !important;
                font-size: 0.85em;
                width: 100%;
                margin-bottom: 5px;
            }
            
            .pi-input-row .pi-input {
                width: 100% !important;
                margin: 0 !important;
                box-sizing: border-box;
                flex: none !important;
            }
            
            .pi-input-row .btn {
                width: 100% !important;
                margin: 5px 0 0 0 !important;
                font-size: 0.8em;
                padding: 8px 12px;
                flex: none !important;
            }
            
            .function-input-row {
                padding: 12px;
                margin-bottom: 12px;
            }
            
            .function-inputs {
                flex-direction: column;
                gap: 10px;
                align-items: stretch;
            }
            
            .function-input-group {
                flex-direction: column;
                align-items: flex-start;
                gap: 5px;
            }
            
            .function-input {
                min-width: auto !important;
                width: 100% !important;
                font-size: 0.9em;
                margin: 0 !important;
                box-sizing: border-box;
            }
            
            .function-input-label {
                font-size: 0.85em;
            }
            
            .example-section {
                margin-top: 15px;
            }
            
            .example-title {
                font-size: 1em;
                padding: 8px 12px;
            }
            
            .example-content {
                padding: 12px;
                font-size: 0.8em;
                line-height: 1.4;
            }
            
            .loading {
                padding: 20px 15px;
            }
            
            .result-area {
                padding: 15px;
            }
            
            .progress-details {
                margin-top: 15px;
            }
            
            .progress-box {
                padding: 12px;
            }
            
            .progress-box h4 {
                font-size: 1em;
                margin-bottom: 8px;
            }
            
            /* PI 輸入區域的按鈕組 */
            #piInputContainer div[style*="display: flex"] {
                display: flex !important;
                flex-direction: column !important;
                gap: 8px !important;
                margin-top: 15px;
            }
            
            #piInputContainer div[style*="display: flex"] .btn {
                flex: none !important;
                width: 100% !important;
                min-width: auto !important;
                font-size: 0.8em;
                padding: 10px 15px;
                margin: 0 !important;
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
                box-sizing: border-box;
            }
            
            /* 特別針對三個按鈕 */
            .btn-add, .btn-secondary, .btn-info {
                width: 100% !important;
                margin: 0 !important;
                margin-bottom: 8px !important;
            }
        }
        
        /* 強制修復 PI 模式手機版問題 */
        @media (max-width: 768px) {
            /* 強制修復 PI 模式底部按鈕組 */
            #piInputContainer > div[style*="display: flex"] {
                display: flex !important;
                flex-direction: column !important;
                align-items: stretch !important;
                gap: 8px !important;
                margin-top: 15px !important;
            }
            
            #piInputContainer > div[style*="display: flex"] .btn {
                width: 100% !important;
                margin: 0 !important;
                white-space: nowrap !important;
                overflow: hidden !important;
                text-overflow: ellipsis !important;
                box-sizing: border-box !important;
            }
            
            /* 強制修復函數標題區域 */
            .function-pi-group .function-pi-header {
                display: flex !important;
                flex-direction: column !important;
                align-items: stretch !important;
                padding: 10px !important;
            }
            
            .function-pi-group .function-pi-header .function-pi-title {
                width: 100% !important;
                margin-bottom: 8px !important;
            }
            
            .function-pi-group .function-pi-header .btn-remove {
                width: 100% !important;
                margin: 0 !important;
                white-space: nowrap !important;
                overflow: hidden !important;
                text-overflow: ellipsis !important;
            }
            
            /* 強制修復 PI 輸入行 */
            .function-pi-inputs .pi-input-row {
                display: flex !important;
                flex-direction: column !important;
                align-items: stretch !important;
                gap: 5px !important;
            }
            
            .function-pi-inputs .pi-input-row .pi-label {
                display: block !important;
                margin-bottom: 4px !important;
                font-weight: bold !important;
            }
            
            .function-pi-inputs .pi-input-row .pi-input {
                width: 100% !important;
                margin: 0 !important;
                box-sizing: border-box !important;
            }
            
            .function-pi-inputs .pi-input-row .btn {
                width: 100% !important;
                margin: 0 !important;
                white-space: nowrap !important;
                overflow: hidden !important;
                text-overflow: ellipsis !important;
            }
        }
        
        /* 超強制修復 PI 模式問題 - 使用更高優先級 */
        @media (max-width: 768px) {
            /* 針對 PI 模式底部按鈕的超強制修復 */
            div[style*="display: flex"][style*="gap: 10px"] {
                flex-direction: column !important;
                align-items: stretch !important;
                gap: 8px !important;
            }
            
            div[style*="display: flex"][style*="gap: 10px"] button {
                width: 100% !important;
                margin: 0 !important;
                flex: none !important;
            }
            
            /* 針對所有 PI 相關按鈕的超強制修復 */
            .btn[onclick*="addFunctionPIGroup"],
            .btn[onclick*="addPIToCurrentFunction"],
            .btn[onclick*="generateFunctionDefinitions"],
            .btn[onclick*="removeFunctionPIGroup"],
            .btn[onclick*="removePIFromFunction"] {
                width: 100% !important;
                margin: 0 !important;
                white-space: nowrap !important;
                overflow: hidden !important;
                text-overflow: ellipsis !important;
                box-sizing: border-box !important;
            }
        }
        
        /* 更小螢幕的額外優化 */
        @media (max-width: 480px) {
            .container {
                margin: 5px;
                border-radius: 8px;
            }
            
            .header {
                padding: 15px 10px;
            }
            
            .header h1 {
                font-size: 1.5em;
            }
            
            .header p {
                font-size: 0.9em;
            }
            
            .input-section, .output-section {
                padding: 15px 10px;
            }
            
            .section-title {
                font-size: 1.2em;
            }
            
            .btn {
                padding: 10px 15px;
                font-size: 0.9em;
            }
            
            .function-pi-title {
                font-size: 0.85em;
                min-width: 150px;
            }
            
            .example-content {
                font-size: 0.75em;
            }
            
            #multiplePIInputs + div .btn {
                min-width: auto;
                font-size: 0.75em;
                padding: 8px 12px;
                width: 100%;
            }
            
            .function-pi-header {
                flex-direction: column;
                gap: 6px;
            }
            
            .btn-remove {
                font-size: 0.7em;
                padding: 6px 10px;
            }
            
            .pi-input-row .btn {
                font-size: 0.7em;
                padding: 6px 10px;
            }
            
            .radio-group {
                padding: 8px 12px;
                font-size: 0.85em;
            }
            
            /* 480px 以下的 PI 模式超強制修復 */
            div[style*="display: flex"] {
                flex-direction: column !important;
                align-items: stretch !important;
            }
            
            div[style*="display: flex"] .btn {
                width: 100% !important;
                margin: 2px 0 !important;
                flex: none !important;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- 標題區域 -->
        <div class="header">
            <h1>🧮 多輸出布林函數最小化工具</h1>
            <p>基於 Patrick Method 演算法的多輸出最佳化系統</p>
        </div>
        
        <!-- 主要內容區域 -->
        <div class="main-content">
            <!-- 輸入區域 -->
            <div class="input-section">
                <h2 class="section-title">📝 輸入設定</h2>
                
                <!-- 變數設定 -->
                <div class="form-group">
                    <label class="form-label">變數設定</label>
                    <div class="variable-input">
                        <input type="text" class="input-field" id="variables" 
                               placeholder="輸入變數 (例如: A,B,C,D 或 W,X,Y,Z)" value="A,B,C,D">
                        <button class="btn btn-secondary" onclick="clearInputs()">清除</button>
                    </div>
                </div>
                
                <!-- 輸入模式選擇 -->
                <div class="form-group">
                    <label class="form-label">輸入模式</label>
                    <div class="input-mode-selector">
                        <label class="radio-group">
                            <input type="radio" name="inputMode" value="pi" id="modePI" checked>
                            <span class="radio-label">Prime Implicants (PI)</span>
                        </label>
                        <label class="radio-group">
                            <input type="radio" name="inputMode" value="minterm" id="modeMinterm">
                            <span class="radio-label">Minterms</span>
                        </label>
                    </div>
                </div>
                
                <!-- 輸入區域 -->
                <div class="form-group">
                    <label class="form-label" id="inputLabel">多函數 Prime Implicants</label>
                    
                    <!-- PI 模式：動態輸入框 -->
                    <div id="piInputContainer">
                        <div id="multiplePIInputs">
                            <!-- 動態生成的函數PI區域將在這裡 -->
                        </div>
                        <div style="display: flex; gap: 10px; margin-top: 15px;">
                            <button type="button" class="btn btn-add" onclick="addFunctionPIGroup()">
                                ➕ 新增函數
                            </button>
                            <button type="button" class="btn btn-secondary" onclick="addPIToCurrentFunction()">
                                ➕ 新增 PI
                            </button>
                            <button type="button" class="btn btn-info" onclick="generateFunctionDefinitions()">
                                🔄 自動生成函數定義
                            </button>
                        </div>
                        
                        <!-- 輸出函數定義輸入區域 -->
                        <div style="margin-top: 25px;">
                            <label style="display: block; font-weight: bold; color: #2c3e50; margin-bottom: 8px; font-size: 1.1em;">
                                輸出函數定義 (各自函數的minterm，不含don't care)
                            </label>
                            <textarea id="outputFunctions" 
                                      placeholder="定義各輸出函數:&#10;F1: 0,2,4&#10;F2: 1,3,5&#10;F3: 2,6,7&#10;&#10;或使用傳統格式:&#10;F1: m0,m2,m4&#10;F2: m1,m3,m5&#10;F3: m2,m6,m7"
                                      style="width: 100%; min-height: 120px; resize: vertical; padding: 12px; border: 2px solid #ddd; border-radius: 8px; font-family: 'Courier New', monospace; font-size: 14px; transition: border-color 0.3s ease;"></textarea>
                            <div style="margin-top: 8px; padding: 10px; background: #e8f4f8; border-radius: 6px; font-size: 13px; color: #0c5460;">
                                💡 <strong>輸入格式:</strong> 支援純數字格式 (F1: 0,2,4) 或傳統格式 (F1: m0,m2,m4)<br>
                                🧠 <strong>自動共享項檢測:</strong> 系統會自動分析PI數據，找出函數間的共享項
                            </div>
                        </div>
                    </div>
                    
                    <!-- Minterm 模式：函數輸入 -->
                    <div id="mintermInputContainer" style="display: none;">
                        <div id="functionInputs">
                            <!-- 動態生成的函數輸入框將在這裡 -->
                        </div>
                        <button type="button" class="btn btn-add" id="addFunctionButton" onclick="addFunctionInput()">
                            ➕ 新增函數
                        </button>
                    </div>
                </div>
                
                <!-- 執行按鈕 -->
                <div class="button-group" style="display: flex; gap: 10px; align-items: center;">
                    <button class="btn btn-primary" onclick="runMultiOutputOptimization()">
                        🚀 執行多輸出最佳化
                    </button>
                    <button class="btn btn-secondary" onclick="shareResults()" title="分享結果">
                        📤 分享結果
                    </button>
                    <button class="btn btn-secondary" onclick="copyResultsToClipboard()" title="複製結果">
                        📋 複製結果
                    </button>
                </div>
                
                <!-- 範例區域 -->
                <div class="example-section">
                    <div class="example-title">💡 輸入格式說明</div>
                    <div class="example-content">
<strong>Prime Implicants 模式:</strong>
變數: W,X,Y,Z
函數 F1:
  PI1: 00-1  (覆蓋 m1,m9)
  PI2: -110  (覆蓋 m6,m14)
函數 F2:
  PI1: 000-  (覆蓋 m0,m1)
  PI2: 01--  (覆蓋 m4,m5,m6,m7)

<strong>Minterms 模式:</strong>
變數: W,X,Y,Z
F1 = Σm(1,5,7,8,10,11,12,14,15) + Σd(3,13)
F2 = Σm(0,1,4,6,7,8,12) + Σd(2,9)

<strong>特色功能:</strong>
• 🎯 自動檢測函數間的共享 Prime Implicants
• ⚡ 智能最佳化，減少總體電路成本
• 🔧 支援 Don't Care 項優化
• 📊 詳細顯示最佳化步驟和結果比較
                    </div>
                </div>
            </div>
            
            <!-- 輸出區域 -->
            <div class="output-section">
                <h2 class="section-title">📊 最佳化結果</h2>
                
                <!-- 載入動畫 -->
                <div class="loading" id="loadingArea">
                    <div class="spinner"></div>
                    <p>正在執行多輸出最佳化演算法...</p>
                    
                    <!-- 進度詳情框 -->
                    <div class="progress-details" id="progressDetails" style="display: none;">
                        <div class="progress-box">
                            <h4>🔍 運算進度詳情</h4>
                            <div class="progress-content" id="progressContent">
                                <!-- 進度信息將在這裡顯示 -->
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- 結果顯示區域 -->
                <div class="result-area" id="resultArea">
                    <div style="text-align: center; color: #6c757d; margin-top: 100px;">
                        <h3>等待輸入...</h3>
                        <p>請在左側輸入多輸出函數資料並點擊執行按鈕</p>
                        <p style="margin-top: 20px;">🔹 支援 Prime Implicants 和 Minterms 兩種輸入模式</p>
                        <p>🔹 自動最佳化多函數共享項</p>
                        <p>🔹 顯示詳細最佳化過程</p>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- 載入核心算法 -->
    <script src="patrick-method-core.js"></script>
    
    <!-- 註冊 Service Worker -->
    <script>
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', function() {
                navigator.serviceWorker.register('./sw.js')
                    .then(function(registration) {
                        console.log('SW registered: ', registration);
                    })
                    .catch(function(registrationError) {
                        console.log('SW registration failed: ', registrationError);
                    });
            });
        }
    </script>
    
    <script>
        // ==================== 全域變數定義 ====================
        let functionPICounter = 1;           // PI 模式下的函數計數器
        let piCounterByFunction = {};        // 每個函數的 PI 計數器對應表
        let currentSelectedFunction = 1;     // 當前選中的函數 ID
        let functionCounter = 1;             // Minterm 模式下的函數計數器
        
        // ==================== 輸入模式切換處理 ====================
        // 監聽輸入模式選項的變化
        document.querySelectorAll('input[name="inputMode"]').forEach(radio => {
            radio.addEventListener('change', function() {
                updateInputMode(this.value);
            });
        });
        
        /**
         * 更新輸入模式顯示
         * 根據選擇的模式（PI 或 Minterm）切換對應的輸入界面
         * @param {string} mode - 輸入模式 ('pi' 或 'minterm')
         */
        function updateInputMode(mode) {
            const inputLabel = document.getElementById('inputLabel');
            const piContainer = document.getElementById('piInputContainer');
            const mintermContainer = document.getElementById('mintermInputContainer');
            
            if (mode === 'pi') {
                // 切換到 PI 模式
                inputLabel.textContent = '多函數 Prime Implicants';
                piContainer.style.display = 'block';
                mintermContainer.style.display = 'none';
                
                // 如果尚未初始化，則初始化 PI 輸入框
                if (document.getElementById('multiplePIInputs').children.length === 0) {
                    initializeMultiplePIInputs();
                }
            } else {
                // 切換到 Minterm 模式
                inputLabel.textContent = '多函數 Minterms';
                piContainer.style.display = 'none';
                mintermContainer.style.display = 'block';
                
                // 如果尚未初始化，則初始化 Minterm 輸入框
                if (document.getElementById('functionInputs').children.length === 0) {
                    initializeFunctionInputs();
                }
            }
        }
        
        /**
         * 初始化多輸出 PI 輸入框
         * 清空現有內容並重置所有計數器，然後添加第一個函數組
         */
        function initializeMultiplePIInputs() {
            const multiplePIInputs = document.getElementById('multiplePIInputs');
            multiplePIInputs.innerHTML = '';
            functionPICounter = 1;
            piCounterByFunction = {};
            currentSelectedFunction = 1;
            addFunctionPIGroup(); // 添加第一個函數組
        }
        
        /**
         * 新增函數 PI 組
         * 創建一個新的函數組，包含標題、PI 輸入區域和控制按鈕
         */
        function addFunctionPIGroup() {
            const multiplePIInputs = document.getElementById('multiplePIInputs');
            
            // 計算當前應該的函數編號（從 1 開始，連續編號）
            const currentFunctionCount = multiplePIInputs.children.length;
            const functionDisplayId = currentFunctionCount + 1;
            const functionId = functionPICounter++;
            piCounterByFunction[functionId] = 1;
            
            const functionDiv = document.createElement('div');
            functionDiv.className = 'function-pi-group';
            functionDiv.id = `functionPIGroup${functionId}`;
            functionDiv.setAttribute('data-display-id', functionDisplayId);
            
            functionDiv.innerHTML = `
                <div class="function-pi-header">
                    <h4 class="function-pi-title" onclick="selectFunction(${functionId})">
                        📝 函數 F${functionDisplayId}
                        <span class="function-pi-indicator" id="indicator${functionId}">● PI 數量: 0</span>
                    </h4>
                    <button class="btn btn-remove" onclick="removeFunctionPIGroup(${functionId})">
                        ✕ 移除函數
                    </button>
                </div>
                <div class="function-pi-inputs" id="functionPIInputs${functionId}">
                    <!-- PI 輸入框將在這裡 -->
                </div>
            `;
            
            multiplePIInputs.appendChild(functionDiv);
            
            // 選中新創建的函數
            selectFunction(functionId);
            
            // 為新函數添加第一個PI
            addPIToFunction(functionId);
        }
        
        // 移除函數 PI 組
        function removeFunctionPIGroup(functionId) {
            if (Object.keys(piCounterByFunction).length <= 1) {
                alert('至少需要保留一個函數！');
                return;
            }
            
            const functionDiv = document.getElementById(`functionPIGroup${functionId}`);
            functionDiv.remove();
            delete piCounterByFunction[functionId];
            
            // 重新整理所有函數的編號
            updatePIFunctionNumbers();
            
            // 如果移除的是當前選中的函數，選中第一個可用的函數
            if (currentSelectedFunction === functionId) {
                const remainingFunctions = Object.keys(piCounterByFunction);
                if (remainingFunctions.length > 0) {
                    selectFunction(parseInt(remainingFunctions[0]));
                }
            }
        }
        
        // 重新整理 PI 模式下所有函數的編號
        function updatePIFunctionNumbers() {
            const multiplePIInputs = document.getElementById('multiplePIInputs');
            const functionGroups = multiplePIInputs.querySelectorAll('.function-pi-group');
            
            functionGroups.forEach((group, index) => {
                const displayId = index + 1;
                group.setAttribute('data-display-id', displayId);
                
                // 更新函數標題
                const functionTitle = group.querySelector('.function-pi-title');
                if (functionTitle) {
                    const titleText = functionTitle.childNodes[0];
                    if (titleText) {
                        titleText.textContent = `📝 函數 F${displayId}`;
                    }
                }
            });
        }
        
        // 選中函數
        function selectFunction(functionId) {
            // 移除之前的選中狀態
            document.querySelectorAll('.function-pi-group').forEach(group => {
                group.style.borderLeftColor = '#28a745';
            });
            
            // 設置新的選中狀態
            const selectedGroup = document.getElementById(`functionPIGroup${functionId}`);
            if (selectedGroup) {
                selectedGroup.style.borderLeftColor = '#007bff';
                currentSelectedFunction = functionId;
            }
        }
        
        // 為當前選中的函數新增 PI
        function addPIToCurrentFunction() {
            if (currentSelectedFunction && piCounterByFunction[currentSelectedFunction] !== undefined) {
                addPIToFunction(currentSelectedFunction);
            } else {
                alert('請先選擇一個函數！');
            }
        }
        
        // 為指定函數新增 PI
        function addPIToFunction(functionId) {
            const functionPIInputs = document.getElementById(`functionPIInputs${functionId}`);
            
            // 計算當前應該的 PI 編號（從1開始，連續編號）
            const currentPICount = functionPIInputs.children.length;
            const piDisplayId = currentPICount + 1;
            const piId = piCounterByFunction[functionId]++;
            
            const piRow = document.createElement('div');
            piRow.className = 'pi-input-row';
            piRow.id = `piRow${functionId}_${piId}`;
            piRow.setAttribute('data-display-id', piDisplayId);
            
            piRow.innerHTML = `
                <span class="pi-label">PI${piDisplayId}:</span>
                <input type="text" class="pi-input" 
                       placeholder="例如: 00-1, -110, 1-01" 
                       oninput="updatePICount(${functionId})">
                <button class="btn btn-remove" onclick="removePIFromFunction(${functionId}, ${piId})">✕</button>
            `;
            
            functionPIInputs.appendChild(piRow);
            updatePICount(functionId);
        }
        
        // 從函數中移除 PI
        function removePIFromFunction(functionId, piId) {
            const piRow = document.getElementById(`piRow${functionId}_${piId}`);
            if (piRow) {
                piRow.remove();
                // 重新整理該函數的 PI 編號
                updatePINumbers(functionId);
                updatePICount(functionId);
            }
        }
        
        // 重新整理指定函數的 PI 編號
        function updatePINumbers(functionId) {
            const functionPIInputs = document.getElementById(`functionPIInputs${functionId}`);
            const piRows = functionPIInputs.querySelectorAll('.pi-input-row');
            
            piRows.forEach((row, index) => {
                const displayId = index + 1;
                row.setAttribute('data-display-id', displayId);
                
                // 更新 PI 標籤
                const piLabel = row.querySelector('.pi-label');
                if (piLabel) {
                    piLabel.textContent = `PI${displayId}:`;
                }
            });
        }
        
        // 更新 PI 數量顯示
        function updatePICount(functionId) {
            const functionPIInputs = document.getElementById(`functionPIInputs${functionId}`);
            const piInputs = functionPIInputs.querySelectorAll('.pi-input');
            const filledPIs = Array.from(piInputs).filter(input => input.value.trim() !== '').length;
            const totalPIs = piInputs.length;
            
            const indicator = document.getElementById(`indicator${functionId}`);
            if (indicator) {
                indicator.textContent = `● PI 數量: ${filledPIs}/${totalPIs}`;
                indicator.className = filledPIs > 0 ? 'function-pi-indicator active' : 'function-pi-indicator';
            }
        }
        
        // 初始化函數輸入框 (Minterm模式)
        function initializeFunctionInputs() {
            const functionInputs = document.getElementById('functionInputs');
            functionInputs.innerHTML = '';
            functionCounter = 1;
            addFunctionInput(); // 添加第一個函數
        }
        
        // 新增函數輸入 (Minterm模式)
        function addFunctionInput() {
            const functionInputs = document.getElementById('functionInputs');
            
            // 計算當前應該的函數編號（從1開始，連續編號）
            const currentFunctionCount = functionInputs.children.length;
            const functionDisplayId = currentFunctionCount + 1;
            const functionId = functionCounter++;
            
            const functionRow = document.createElement('div');
            functionRow.className = 'function-input-row';
            functionRow.id = `functionRow${functionId}`;
            functionRow.setAttribute('data-display-id', functionDisplayId);
            
            functionRow.innerHTML = `
                <div class="function-header">
                    <span class="function-label">函數 F${functionDisplayId}</span>
                    <button class="btn btn-remove" onclick="removeFunctionInput(${functionId})">
                        ✕ 移除函數
                    </button>
                </div>
                <div class="function-inputs">
                    <div style="width: 100%;">
                        <span class="function-input-label">F${functionDisplayId} = Σm(</span>
                        <input type="text" class="function-input" 
                               placeholder="" 
                               id="minterms${functionId}"
                               style="width: 150px; display: inline-block; margin: 0 5px;">
                        <span class="function-input-label">) + Σd(</span>
                        <input type="text" class="function-input" 
                               placeholder="" 
                               id="dontcare${functionId}"
                               style="width: 120px; display: inline-block; margin: 0 5px;">
                        <span class="function-input-label">)</span>
                    </div>
                </div>
            `;
            
            functionInputs.appendChild(functionRow);
        }
        
        // 移除函數輸入 (Minterm模式)
        function removeFunctionInput(functionId) {
            const functionInputs = document.getElementById('functionInputs');
            if (functionInputs.children.length <= 1) {
                alert('至少需要保留一個函數！');
                return;
            }
            
            const functionRow = document.getElementById(`functionRow${functionId}`);
            if (functionRow) {
                functionRow.remove();
                // 重新整理所有函數的編號
                updateMintermFunctionNumbers();
            }
        }
        
        // 重新整理 Minterm 模式下所有函數的編號
        function updateMintermFunctionNumbers() {
            const functionInputs = document.getElementById('functionInputs');
            const functionRows = functionInputs.querySelectorAll('.function-input-row');
            
            functionRows.forEach((row, index) => {
                const displayId = index + 1;
                row.setAttribute('data-display-id', displayId);
                
                // 更新函數標題
                const functionLabel = row.querySelector('.function-label');
                if (functionLabel) {
                    functionLabel.textContent = `函數 F${displayId}`;
                }
                
                // 更新函數表達式中的編號
                const functionLabels = row.querySelectorAll('.function-input-label');
                functionLabels.forEach(label => {
                    if (label.textContent.includes('F') && label.textContent.includes('=')) {
                        label.textContent = `F${displayId} = Σm(`;
                    }
                });
            });
        }
        
        // 清除所有輸入
        function clearInputs() {
            document.getElementById('variables').value = '';
            
            const currentMode = document.querySelector('input[name="inputMode"]:checked').value;
            if (currentMode === 'pi') {
                initializeMultiplePIInputs();
            } else {
                initializeFunctionInputs();
            }
        }
        
        // 執行多輸出最佳化
        function runMultiOutputOptimization() {
            const loadingArea = document.getElementById('loadingArea');
            const resultArea = document.getElementById('resultArea');
            
            // 顯示載入動畫
            loadingArea.classList.add('show');
            resultArea.innerHTML = '';
            
            // 收集輸入資料
            const variables = document.getElementById('variables').value.trim();
            const inputMode = document.querySelector('input[name="inputMode"]:checked').value;
            
            if (!variables) {
                setTimeout(() => {
                    loadingArea.classList.remove('show');
                    resultArea.innerHTML = `
                        <div style="color: #dc3545; text-align: center; margin-top: 50px;">
                            <h3>❌ 輸入錯誤</h3>
                            <p>請先設定變數！</p>
                        </div>
                    `;
                }, 1000);
                return;
            }
            
            let inputData = {};
            let hasValidInput = false;

            if (inputMode === 'pi') {
                // 收集 PI 資料
                inputData = collectPIData();
                hasValidInput = Object.keys(inputData).length > 0;
                
                // 同時收集輸出函數定義（如果有的話）
                const outputFunctionsValue = document.getElementById('outputFunctions').value.trim();
                if (outputFunctionsValue) {
                    inputData.outputFunctions = parseOutputFunctions(outputFunctionsValue);
                }
            } else {
                // 收集 Minterm 資料
                inputData = collectMintermData();
                hasValidInput = Object.keys(inputData).length > 0;
            }
            
            if (!hasValidInput) {
                setTimeout(() => {
                    loadingArea.classList.remove('show');
                    resultArea.innerHTML = `
                        <div style="color: #dc3545; text-align: center; margin-top: 50px;">
                            <h3>❌ 輸入錯誤</h3>
                            <p>請至少輸入一個函數的資料！</p>
                        </div>
                    `;
                }, 1000);
                return;
            }
            
            // 執行真正的Patrick Method算法
            setTimeout(() => {
                try {
                    executePatrickMethod(variables, inputData, inputMode);
                } catch (error) {
                    console.error('執行錯誤:', error);
                    loadingArea.classList.remove('show');
                    resultArea.innerHTML = `
                        <div style="color: #dc3545; text-align: center; margin-top: 50px;">
                            <h3>❌ 計算錯誤</h3>
                            <p>${error.message}</p>
                        </div>
                    `;
                }
            }, 1000);
        }
        
        /**
         * 執行 Patrick Method 演算法主函數
         * 處理輸入資料並調用核心演算法進行最佳化
         * @param {string} variables - 變數字串
         * @param {Object} inputData - 輸入資料物件
         * @param {string} inputMode - 輸入模式（'pi' 或 'minterm'）
         */
        function executePatrickMethod(variables, inputData, inputMode) {
            const loadingArea = document.getElementById('loadingArea');
            const resultArea = document.getElementById('resultArea');
            
            try {
                console.log('🚀 開始執行 Patrick Method');
                console.log('變數:', variables);
                console.log('輸入資料:', inputData);
                console.log('輸入模式:', inputMode);
                
                // 解析變數字串為陣列
                const variableList = variables.split(',').map(v => v.trim());
                const numVars = variableList.length;
                
                let mintermsByFunction = {};
                
                if (inputMode === 'pi') {
                    // PI 模式：需要使用輸出函數定義
                    if (inputData.outputFunctions && Object.keys(inputData.outputFunctions).length > 0) {
                        // 使用輸出函數定義中的 minterms
                        Object.entries(inputData.outputFunctions).forEach(([funcName, funcData]) => {
                            mintermsByFunction[funcName] = funcData.minterms || [];
                        });
                    } else {
                        // 如果沒有輸出函數定義，從 PI 計算 minterms
                        Object.entries(inputData).forEach(([funcName, pis]) => {
                            if (funcName !== 'outputFunctions' && Array.isArray(pis)) {
                                const minterms = new Set();
                                pis.forEach(pi => {
                                    const piValue = pi.trim();
                                    if (piValue) {
                                        const coveredMinterms = calculateMintermsFromPI(piValue, numVars);
                                        coveredMinterms.forEach(m => minterms.add(m));
                                    }
                                });
                                mintermsByFunction[funcName] = Array.from(minterms).sort((a, b) => a - b);
                            }
                        });
                    }
                } else {
                    // Minterm模式：收集minterms和don't care項
                    const allDontCares = new Set();
                    
                    Object.entries(inputData).forEach(([funcName, funcData]) => {
                        mintermsByFunction[funcName] = funcData.minterms || [];
                        
                        // 收集don't care項
                        if (funcData.dontcare && funcData.dontcare.length > 0) {
                            const dontcares = funcData.dontcare.map(m => 
                                typeof m === 'string' ? parseInt(m.trim()) : m
                            ).filter(m => !isNaN(m));
                            dontcares.forEach(dc => allDontCares.add(dc));
                        }
                    });
                    
                    // 將所有don't care項傳遞給算法
                    var dontCares = Array.from(allDontCares);
                }
                
                console.log('處理後的minterms:', mintermsByFunction);
                
                // 檢查是否有有效的函數資料
                const validFunctions = Object.keys(mintermsByFunction).filter(
                    funcName => mintermsByFunction[funcName].length > 0
                );
                
                if (validFunctions.length === 0) {
                    throw new Error('沒有找到有效的函數資料！請檢查輸入。');
                }
                
                // 創建MultipleOutputPatrick實例
                const multiPatrick = new MultipleOutputPatrick();
                
                // 設定變數
                multiPatrick.variables = variableList;
                
                // 執行多輸出最佳化
                console.log('執行多輸出最佳化...');
                const results = multiPatrick.executeMultipleOutput(mintermsByFunction, numVars, dontCares || []);
                
                console.log('最佳化結果:', results);
                
                // 顯示結果
                loadingArea.classList.remove('show');
                displayPatrickMethodResults(results, variableList);
                
            } catch (error) {
                console.error('Patrick Method執行錯誤:', error);
                loadingArea.classList.remove('show');
                resultArea.innerHTML = `
                    <div style="color: #dc3545; text-align: center; margin-top: 50px;">
                        <h3>❌ 計算錯誤</h3>
                        <p>${error.message}</p>
                        <details style="margin-top: 15px; text-align: left;">
                            <summary>錯誤詳情</summary>
                            <pre style="margin-top: 10px; padding: 10px; background: #f8f9fa; border-radius: 4px; font-size: 12px;">${error.stack}</pre>
                        </details>
                    </div>
                `;
            }
        }
        
        /**
         * 計算單個系統解決方案的成本
         * 包括個別成本、共享成本和節省成本的計算
         * @param {Object} systemSolution - 系統解決方案物件
         * @returns {Object} 包含各種成本資訊的物件
         */
        function calculateSolutionCosts(systemSolution) {
            // 計算個別成本總和（不考慮共享）
            let totalIndividualCost = 0;
            Object.values(systemSolution).forEach(solution => {
                totalIndividualCost += solution.cost;
            });

            // 統計 Prime Implicants 使用次數
            const piUsageCount = new Map();
            Object.values(systemSolution).forEach(solution => {
                solution.pis.forEach(pi => {
                    const count = piUsageCount.get(pi.pattern) || 0;
                    piUsageCount.set(pi.pattern, count + 1);
                });
            });

            // 計算重複 PI 的成本節省
            let duplicatedPICost = 0;
            piUsageCount.forEach((count, pattern) => {
                if (count > 1) {
                    // 從任一使用此 PI 的函數中獲取 PI 成本
                    const piCost = Object.values(systemSolution)
                        .flatMap(sol => sol.pis)
                        .find(pi => pi.pattern === pattern)?.cost || 0;
                    duplicatedPICost += (count - 1) * piCost;
                    console.log(`PI ${pattern} 使用 ${count} 次，成本 ${piCost}，節省成本: ${(count-1) * piCost}`);
                }
            });
            console.log(`總重複 PI 成本: ${duplicatedPICost}`);

            const sharedCost = totalIndividualCost - duplicatedPICost;
            const savings = totalIndividualCost - sharedCost;

            return {
                totalIndividualCost,
                sharedCost,
                savings
            };
        }

        /**
         * 顯示 Patrick Method 演算法結果
         * 格式化並展示最佳化結果，包括解決方案和成本分析
         * @param {Object} results - 演算法執行結果
         * @param {Array} variables - 變數陣列
         */
        function displayPatrickMethodResults(results, variables) {
            const resultArea = document.getElementById('resultArea');
            resultArea.classList.add('has-content');
            
            if (!results.success) {
                resultArea.innerHTML = `<div style="color: #dc3545;">❌ 計算失敗<br>${results.error || '未知錯誤'}</div>`;
                return;
            }
            
            let resultText = '';
            
            // 判斷是單函數還是多函數模式
            let isSingleFunction = false;
            if (results.solutions) {
                isSingleFunction = Object.keys(results.solutions).length === 1;
            } else if (results.systemSolutions && results.systemSolutions.length > 0) {
                isSingleFunction = Object.keys(results.systemSolutions[0]).length === 1;
            } else if (results.allFormattedSolutions && results.allFormattedSolutions.length > 0) {
                // 檢查第一個格式化解決方案的函數數量
                const firstSolution = results.allFormattedSolutions[0];
                if (firstSolution.expressions) {
                    isSingleFunction = firstSolution.expressions.length === 1;
                }
            }
            
            // 優先使用新的統一格式化顯示
            console.log('🔍 檢查格式化解決方案:', results.allFormattedSolutions);
            if (results.allFormattedSolutions && results.allFormattedSolutions.length > 0) {
                console.log('✅ 使用新的統一格式化顯示');
                resultText += `📊 最佳化結果\n`;
                resultText += `🎯 多輸出最佳化結果\n`;
                resultText += `變數: ${variables.join(', ')}\n\n`;
                
                if (results.allFormattedSolutions.length > 1) {
                    resultText += `🎯 找到 ${results.allFormattedSolutions.length} 個相同成本的最佳解決方案\n\n`;
                    
                    results.allFormattedSolutions.forEach((formattedSolution, index) => {
                        resultText += `🔹 解決方案 ${index + 1}:\n`;
                        if (formattedSolution.expressions) {
                            formattedSolution.expressions.forEach(expression => {
                                resultText += `${expression}\n`;
                            });
                        }
                        if (formattedSolution.usedPIPatterns) {
                            resultText += `使用的PI: ${formattedSolution.usedPIPatterns.join(', ')}\n`;
                        }
                        if (formattedSolution.sharedCost !== undefined) {
                            resultText += `共享成本: ${formattedSolution.sharedCost} 個閘級\n`;
                        }
                        resultText += '\n';
                    });
                } else {
                    // 單一解決方案
                    const formattedSolution = results.allFormattedSolutions[0];
                    resultText += `🔹 解決方案:\n`;
                    if (formattedSolution.expressions) {
                        formattedSolution.expressions.forEach(expression => {
                            resultText += `${expression}\n`;
                        });
                    }
                    if (formattedSolution.usedPIPatterns) {
                        resultText += `使用的PI: ${formattedSolution.usedPIPatterns.join(', ')}\n`;
                    }
                    if (formattedSolution.sharedCost !== undefined) {
                        resultText += `共享成本: ${formattedSolution.sharedCost} 個閘級\n`;
                    }
                    resultText += '\n';
                }
                
                // 成本分析
                if (results.totalIndividualCost && results.sharedOptimizedCost) {
                    resultText += `💰 成本分析\n`;
                    if (isSingleFunction) {
                        resultText += `成本計算方式：1個literal成本=1，多個literals成本=literal數量+1\n`;
                        resultText += `例如：y 有 1 個符號，成本為 1；x'z' 有 2 個符號，成本為 2 + 1 = 3\n\n`;
                    } else {
                        resultText += `成本計算方式：每個項的成本 = 符號數量 + 1\n`;
                        resultText += `例如：x'z' 有 2 個符號，成本為 2 + 1 = 3\n\n`;
                    }
                    resultText += `個別最佳化總成本: ${results.totalIndividualCost}\n`;
                    resultText += `共享最佳化總成本: ${results.sharedOptimizedCost}\n`;
                    
                    if (results.savings > 0) {
                        resultText += `💡 節省成本: ${results.savings} (${((results.savings / results.totalIndividualCost) * 100).toFixed(1)}%)\n`;
                    }
                    resultText += '\n';
                }
                
                // 計算步驟詳解
                if (results.calculationSteps && results.calculationSteps.length > 0) {
                    resultText += `🔍 計算步驟詳解\n\n`;
                    results.calculationSteps.forEach(step => {
                        resultText += `步驟 ${step.step}: ${step.title}\n`;
                        resultText += `${step.description}\n`;
                        resultText += `${step.details.join('\n')}\n\n`;
                    });
                }
                
            } else {
                // 回退到傳統顯示方式
                console.log('⚠️ 未找到格式化解決方案，使用傳統顯示方式');
                console.log('results.allFormattedSolutions:', results.allFormattedSolutions);
                console.log('results.formattedSolution:', results.formattedSolution);
                
                // 主要結果標題
                resultText += `🎯 多輸出最佳化結果\n`;
                resultText += `變數: ${variables.join(', ')}\n\n`;
                
                // 系統解顯示
                if (results.systemSolutions && results.systemSolutions.length > 1) {
                resultText += `🎯 找到 ${results.systemSolutions.length} 個相同成本的最佳解決方案\n\n`;
                
                results.systemSolutions.forEach((systemSolution, index) => {
                    resultText += `🔹 解決方案 ${index + 1}:\n`;
                    
                    // 按照F1, F2, F3...的順序排序
                    const sortedEntries = Object.entries(systemSolution).sort(([a], [b]) => {
                        const numA = parseInt(a.replace('F', ''));
                        const numB = parseInt(b.replace('F', ''));
                        return numA - numB;
                    });
                    
                    // 顯示函數表達式
                    sortedEntries.forEach(([funcName, solution]) => {
                        resultText += `  ${funcName} = ${solution.expression}\n`;
                    });
                    
                    // 收集使用的PI並計算成本
                    const usedPIs = [];
                    sortedEntries.forEach(([funcName, solution]) => {
                        solution.pis.forEach(pi => {
                            if (!usedPIs.find(p => p.pattern === pi.pattern)) {
                                usedPIs.push(pi);
                            }
                        });
                    });
                    
                    resultText += `  使用的PI: ${usedPIs.map(pi => pi.pattern).join(', ')}\n`;
                    resultText += `  成本: ${usedPIs.reduce((sum, pi) => sum + pi.cost, 0)} 個閘級\n\n`;
                });
                
                // 添加成本統計
                resultText += `💰 多重解成本分析\n`;
                const firstSolution = results.systemSolutions[0];
                const solutionCosts = calculateSolutionCosts(firstSolution);
                
                resultText += `所有解決方案成本相同: ${solutionCosts.sharedCost}\n`;
                if (solutionCosts.savings > 0) {
                    resultText += `相比個別最佳化節省: ${solutionCosts.savings} (${((solutionCosts.savings / solutionCosts.totalIndividualCost) * 100).toFixed(1)}%)\n`;
                }
                resultText += '\n';
                
            } else if (results.systemSolutions && results.systemSolutions.length === 1) {
                // 單一系統解
                resultText += `🎯 唯一最佳解決方案\n\n`;
                
                const systemSolution = results.systemSolutions[0];
                const sortedEntries = Object.entries(systemSolution).sort(([a], [b]) => {
                    const numA = parseInt(a.replace('F', ''));
                    const numB = parseInt(b.replace('F', ''));
                    return numA - numB;
                });
                
                sortedEntries.forEach(([funcName, solution]) => {
                    resultText += `${funcName} = ${solution.expression}\n`;
                });
                
                const usedPIs = [];
                sortedEntries.forEach(([funcName, solution]) => {
                    solution.pis.forEach(pi => {
                        if (!usedPIs.find(p => p.pattern === pi.pattern)) {
                            usedPIs.push(pi);
                        }
                    });
                });
                
                resultText += `使用的PI: ${usedPIs.map(pi => pi.pattern).join(', ')}\n`;
                resultText += `成本: ${usedPIs.reduce((sum, pi) => sum + pi.cost, 0)} 個閘級\n\n`;
                
            } else if (results.allSolutions && results.allSolutions.length > 1) {
                // 檢查是單函數還是多函數的多解
                const firstSolution = results.allSolutions[0];
                const isMultiFunction = firstSolution && firstSolution.functions && Object.keys(firstSolution.functions).length > 1;
                
                if (isMultiFunction) {
                    // 多函數多解顯示
                    resultText += `🎯 找到 ${results.allSolutions.length} 個相同成本的最佳解決方案\n\n`;
                    
                    results.allSolutions.forEach((solution) => {
                        resultText += `🔹 解決方案 ${solution.solutionNumber}:\n`;
                        
                        // 安全檢查 solution.functions
                        if (solution.functions && typeof solution.functions === 'object') {
                            // 按照F1, F2, F3...的順序顯示函數
                            const sortedFunctions = Object.entries(solution.functions).sort(([a], [b]) => {
                                const numA = parseInt(a.replace('F', ''));
                                const numB = parseInt(b.replace('F', ''));
                                return numA - numB;
                            });
                            
                            sortedFunctions.forEach(([funcName, funcData]) => {
                                resultText += `  ${funcName} = ${funcData.expression}\n`;
                            });
                        }
                        
                        if (solution.usedPIPatterns) {
                            resultText += `  使用的PI: ${solution.usedPIPatterns.join(', ')}\n`;
                        }
                        if (solution.sharedCost !== undefined) {
                            resultText += `  共享成本: ${solution.sharedCost} 個閘級\n`;
                        }
                        resultText += `\n`;
                    });
                } else {
                    // 單函數多解顯示
                    resultText += `🎯 找到 ${results.allSolutions.length} 個相同成本的最佳解決方案\n\n`;
                    
                    results.allSolutions.forEach((solution, index) => {
                        resultText += `解決方案 ${index + 1}: ${results.functionName || 'F1'} = ${solution.expression}\n`;
                        if (solution.pis) {
                            resultText += `使用的PI: ${solution.pis.map(pi => pi.pattern).join(', ')} | 成本: ${solution.cost} 個閘級\n\n`;
                        }
                    });
                }
                
            } else if (Object.keys(results.solutions || {}).length === 1 && results.allSolutions && results.allSolutions.length > 1) {
                // 單函數多解顯示
                resultText += `🎯 找到 ${results.allSolutions.length} 個相同成本的最佳解決方案\n\n`;
                
                results.allSolutions.forEach((solution, index) => {
                    resultText += `解決方案 ${index + 1}: ${results.functionName} = ${solution.expression}\n`;
                    resultText += `使用的PI: ${solution.pis.map(pi => pi.pattern).join(', ')} | 成本: ${solution.cost} 個閘級\n\n`;
                });
                
            } else {
                // 傳統顯示方式
                resultText += `📊 各函數最佳化結果\n`;
                if (results.solutions && typeof results.solutions === 'object') {
                    Object.entries(results.solutions).forEach(([funcName, solution]) => {
                        if (solution && typeof solution === 'object') {
                            resultText += `${funcName}: ${funcName} = ${solution.expression || '無表達式'}\n`;
                            if (solution.pis && Array.isArray(solution.pis)) {
                                resultText += `使用的PI: ${solution.pis.map(pi => pi.pattern || pi).join(', ')} | 成本: ${solution.cost || 0}\n\n`;
                            } else {
                                resultText += `成本: ${solution.cost || 0}\n\n`;
                            }
                        }
                    });
                } else {
                    resultText += `無解決方案數據\n\n`;
                }
            }
            
            // 共享Prime Implicants
            if (results.sharedPIs && results.sharedPIs.length > 0) {
                resultText += `🔄 共享Prime Implicants\n`;
                results.sharedPIs.forEach(sharedPI => {
                    const algebraic = convertPatternToAlgebraicDisplay(sharedPI.pattern, variables);
                    resultText += `${sharedPI.pattern} → ${algebraic} (用於: ${sharedPI.usedBy.join(', ')}, 成本: ${sharedPI.cost})\n`;
                });
                resultText += '\n';
            }
            
            // 成本分析
            resultText += `💰 成本分析\n`;
            if (isSingleFunction) {
                resultText += `成本計算方式：1個literal成本=1，多個literals成本=literal數量+1\n`;
                resultText += `例如：y 有 1 個符號，成本為 1；x'z' 有 2 個符號，成本為 2 + 1 = 3\n\n`;
            } else {
                resultText += `成本計算方式：每個項的成本 = 符號數量 + 1\n`;
                resultText += `例如：x'z' 有 2 個符號，成本為 2 + 1 = 3\n\n`;
            }
            resultText += `個別最佳化總成本: ${results.totalIndividualCost}\n`;
            resultText += `共享最佳化總成本: ${results.sharedOptimizedCost}\n`;
            
            if (results.savings > 0) {
                resultText += `💡 節省成本: ${results.savings} (${((results.savings / results.totalIndividualCost) * 100).toFixed(1)}%)\n`;
            }
            resultText += '\n';
            
            // 計算步驟詳解
            if (results.calculationSteps && results.calculationSteps.length > 0) {
                resultText += `🔍 計算步驟詳解\n\n`;
                results.calculationSteps.forEach(step => {
                    resultText += `步驟 ${step.step}: ${step.title}\n`;
                    resultText += `${step.description}\n`;
                    resultText += `${step.details.join('\n')}\n\n`;
                });
            }
            
            }
            
            // 將純文字轉換為HTML，保留換行
            const resultHTML = resultText.replace(/\n/g, '<br>');
            resultArea.innerHTML = `<div style="font-family: 'Courier New', monospace; line-height: 1.5; white-space: pre-wrap;">${resultHTML}</div>`;
        }
        
        // 輔助函數：將pattern轉換為代數表達式顯示
        function convertPatternToAlgebraicDisplay(pattern, variables) {
            let algebraic = '';
            
            for (let i = 0; i < pattern.length; i++) {
                if (pattern[i] === '1') {
                    algebraic += variables[i] || `X${i}`;
                } else if (pattern[i] === '0') {
                    algebraic += (variables[i] || `X${i}`) + "'";
                }
            }
            
            return algebraic || '1';
        }
        
        // 收集 PI 資料
        function collectPIData() {
            const data = {};
            const multiplePIInputs = document.getElementById('multiplePIInputs');
            const functionGroups = multiplePIInputs.querySelectorAll('.function-pi-group');
            
            functionGroups.forEach((group, index) => {
                const displayId = group.getAttribute('data-display-id') || (index + 1);
                const functionId = group.id.replace('functionPIGroup', '');
                const functionPIInputs = document.getElementById(`functionPIInputs${functionId}`);
                const piInputs = functionPIInputs.querySelectorAll('.pi-input');
                const pis = Array.from(piInputs)
                    .map(input => input.value.trim())
                    .filter(value => value !== '');
                
                if (pis.length > 0) {
                    data[`F${displayId}`] = pis;
                }
            });
            
            return data;
        }
        
        // 收集 Minterm 資料
        function collectMintermData() {
            const data = {};
            
            const functionInputs = document.getElementById('functionInputs');
            const functionRows = functionInputs.querySelectorAll('.function-input-row');
            
            functionRows.forEach((row, index) => {
                const displayId = row.getAttribute('data-display-id') || (index + 1);
                const functionId = row.id.replace('functionRow', '');
                const mintermsInput = document.getElementById(`minterms${functionId}`);
                const dontcareInput = document.getElementById(`dontcare${functionId}`);
                
                const minterms = mintermsInput ? mintermsInput.value.trim() : '';
                const dontcare = dontcareInput ? dontcareInput.value.trim() : '';
                
                if (minterms) {
                    data[`F${displayId}`] = {
                        minterms: minterms.split(',').map(m => m.trim()).filter(m => m),
                        dontcare: dontcare ? dontcare.split(',').map(m => m.trim()).filter(m => m) : []
                    };
                }
            });
            
            return data;
        }
        
        // 自動生成函數定義 (PI 模式)
        function generateFunctionDefinitions() {
            const variables = document.getElementById('variables').value.trim();
            
            if (!variables) {
                alert('請先設定變數！');
                return;
            }
            
            const variableList = variables.split(',').map(v => v.trim());
            const numVars = variableList.length;
            
            if (numVars === 0) {
                alert('請輸入有效的變數！');
                return;
            }
            
            // 收集 PI 資料
            const piData = collectPIData();
            
            if (Object.keys(piData).length === 0) {
                alert('請先輸入 Prime Implicants！');
                return;
            }
            
            let functionDefinitions = [];
            
            // 為每個函數計算 minterms
            Object.keys(piData).forEach(functionName => {
                const pis = piData[functionName];
                const minterms = new Set();
                
                pis.forEach(pi => {
                    const piValue = pi.trim();
                    if (piValue) {
                        // 計算這個 PI 覆蓋的所有 minterms
                        const coveredMinterms = calculateMintermsFromPI(piValue, numVars);
                        coveredMinterms.forEach(m => minterms.add(m));
                    }
                });
                
                // 轉換為排序後的陣列
                const sortedMinterms = Array.from(minterms).sort((a, b) => a - b);
                
                if (sortedMinterms.length > 0) {
                    functionDefinitions.push(`${functionName}: ${sortedMinterms.join(',')}`);
                }
            });
            
            // 將生成的函數定義填入文本域
            const outputFunctionsTextarea = document.getElementById('outputFunctions');
            if (outputFunctionsTextarea) {
                outputFunctionsTextarea.value = functionDefinitions.join('\n');
                
                // 顯示成功訊息
                alert(`✅ 已自動生成 ${functionDefinitions.length} 個函數的定義！\n\n請檢查並確認輸出函數定義區域的內容。`);
                
                // 讓文本域獲得焦點並滾動到該位置
                outputFunctionsTextarea.focus();
                outputFunctionsTextarea.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        }
        
        // 解析輸出函數定義
        function parseOutputFunctions(outputFunctionsText) {
            const outputFunctions = {};
            const lines = outputFunctionsText.split('\n').filter(line => line.trim());
            
            lines.forEach(line => {
                const trimmedLine = line.trim();
                if (trimmedLine.includes(':')) {
                    const [functionPart, mintermsPart] = trimmedLine.split(':').map(part => part.trim());
                    
                    // 提取函數名稱（移除可能的 'F' 前綴）
                    let functionName = functionPart;
                    if (functionName.match(/^F\d+$/)) {
                        // 保持 F1, F2 格式
                    } else if (functionName.match(/^\d+$/)) {
                        // 如果只是數字，加上 F 前綴
                        functionName = 'F' + functionName;
                    }
                    
                    // 解析 minterms（支援多種格式）
                    let minterms = [];
                    if (mintermsPart) {
                        // 移除可能的 'm' 前綴和空格
                        const cleanMinterms = mintermsPart.replace(/m/g, '').replace(/\s/g, '');
                        minterms = cleanMinterms.split(',')
                            .map(term => term.trim())
                            .filter(term => term && !isNaN(term))
                            .map(term => parseInt(term));
                    }
                    
                    if (minterms.length > 0) {
                        outputFunctions[functionName] = {
                            minterms: minterms.sort((a, b) => a - b),
                            dontcare: [] // 預設沒有 don't care
                        };
                    }
                }
            });
            
            return outputFunctions;
        }
        
        // 從 PI 計算覆蓋的 minterms
        function calculateMintermsFromPI(pi, numVars) {
            const minterms = [];
            
            // 移除空格並驗證長度
            pi = pi.replace(/\s/g, '');
            if (pi.length !== numVars) {
                console.warn(`PI "${pi}" 長度不符合變數數量 ${numVars}`);
                return minterms;
            }
            
            // 計算所有可能的組合
            const dontCarePositions = [];
            const fixedBits = [];
            
            for (let i = 0; i < pi.length; i++) {
                if (pi[i] === '-') {
                    dontCarePositions.push(i);
                    fixedBits.push(0); // 暫時設為0
                } else if (pi[i] === '0' || pi[i] === '1') {
                    fixedBits.push(parseInt(pi[i]));
                } else {
                    console.warn(`PI "${pi}" 包含無效字符 "${pi[i]}"`);
                    return minterms;
                }
            }
            
            // 生成所有可能的組合
            const numCombinations = Math.pow(2, dontCarePositions.length);
            
            for (let combo = 0; combo < numCombinations; combo++) {
                const currentBits = [...fixedBits];
                
                // 設置 don't care 位置的值
                for (let i = 0; i < dontCarePositions.length; i++) {
                    const pos = dontCarePositions[i];
                    const bit = (combo >> i) & 1;
                    currentBits[pos] = bit;
                }
                
                // 計算 minterm 值
                let mintermValue = 0;
                for (let i = 0; i < currentBits.length; i++) {
                    mintermValue += currentBits[i] * Math.pow(2, numVars - 1 - i);
                }
                
                minterms.push(mintermValue);
            }
            
            return minterms.sort((a, b) => a - b);
        }
        
        // URL 參數處理和分享功能
        function initializeFromURL() {
            const urlParams = new URLSearchParams(window.location.search);
            
            // 處理模式切換
            const mode = urlParams.get('mode');
            if (mode === 'pi' || mode === 'minterm') {
                updateInputMode(mode);
            } else {
                updateInputMode('pi'); // 默認為 PI 模式
            }
            
            // 處理分享的內容
            const sharedTitle = urlParams.get('title');
            const sharedText = urlParams.get('text');
            const sharedUrl = urlParams.get('url');
            
            if (sharedText) {
                // 嘗試解析分享的文本作為函數定義
                try {
                    const outputFunctionsTextarea = document.getElementById('outputFunctions');
                    if (outputFunctionsTextarea && sharedText.includes(':')) {
                        outputFunctionsTextarea.value = sharedText;
                        alert('已載入分享的函數定義！');
                    }
                } catch (error) {
                    console.log('無法解析分享的內容:', error);
                }
            }
        }
        
        // 分享當前結果
        function shareResults() {
            if (!navigator.share) {
                // 降級到複製到剪貼板
                copyResultsToClipboard();
                return;
            }
            
            const resultArea = document.getElementById('resultArea');
            if (!resultArea || !resultArea.innerHTML.trim() || resultArea.innerHTML.includes('等待輸入')) {
                alert('請先執行 Patrick Method 以獲得結果！');
                return;
            }
            
            // 收集當前的函數定義
            let shareText = '';
            const outputFunctionsTextarea = document.getElementById('outputFunctions');
            if (outputFunctionsTextarea && outputFunctionsTextarea.value.trim()) {
                shareText = outputFunctionsTextarea.value.trim();
            }
            
            // 如果沒有函數定義，嘗試從結果中提取
            if (!shareText) {
                const resultText = resultArea.textContent || resultArea.innerText;
                const lines = resultText.split('\n').filter(line => line.trim());
                shareText = lines.slice(0, 10).join('\n'); // 取前10行
            }
            
            navigator.share({
                title: '布林函數最小化結果',
                text: shareText,
                url: window.location.href
            }).catch(error => {
                console.log('分享失敗:', error);
                copyResultsToClipboard();
            });
        }
        
        // 複製結果到剪貼板（降級方案）
        function copyResultsToClipboard() {
            const resultArea = document.getElementById('resultArea');
            if (!resultArea || !resultArea.innerHTML.trim() || resultArea.innerHTML.includes('等待輸入')) {
                alert('請先執行 Patrick Method 以獲得結果！');
                return;
            }
            
            const resultText = resultArea.textContent || resultArea.innerText;
            
            if (navigator.clipboard) {
                navigator.clipboard.writeText(resultText).then(() => {
                    alert('結果已複製到剪貼板！');
                }).catch(error => {
                    console.log('複製失敗:', error);
                    fallbackCopyToClipboard(resultText);
                });
            } else {
                fallbackCopyToClipboard(resultText);
            }
        }
        
        // 降級複製方案
        function fallbackCopyToClipboard(text) {
            const textArea = document.createElement('textarea');
            textArea.value = text;
            textArea.style.position = 'fixed';
            textArea.style.left = '-999999px';
            textArea.style.top = '-999999px';
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            
            try {
                document.execCommand('copy');
                alert('結果已複製到剪貼板！');
            } catch (error) {
                console.log('複製失敗:', error);
                alert('無法複製到剪貼板，請手動選擇並複製結果。');
            }
            
            document.body.removeChild(textArea);
        }
        
        // 處理檔案拖放和開啟
        function setupFileHandling() {
            const dropZone = document.body;
            
            // 防止預設的拖放行為
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                dropZone.addEventListener(eventName, preventDefaults, false);
            });
            
            function preventDefaults(e) {
                e.preventDefault();
                e.stopPropagation();
            }
            
            // 處理檔案拖放
            dropZone.addEventListener('drop', handleDrop, false);
            
            function handleDrop(e) {
                const dt = e.dataTransfer;
                const files = dt.files;
                
                if (files.length > 0) {
                    handleFiles(files);
                }
            }
            
            function handleFiles(files) {
                Array.from(files).forEach(file => {
                    if (file.type === 'text/plain' || file.type === 'application/json' || file.name.endsWith('.txt')) {
                        const reader = new FileReader();
                        reader.onload = function(e) {
                            const content = e.target.result;
                            loadContentFromFile(content);
                        };
                        reader.readAsText(file);
                    }
                });
            }
            
            function loadContentFromFile(content) {
                try {
                    // 嘗試載入為函數定義
                    const outputFunctionsTextarea = document.getElementById('outputFunctions');
                    if (outputFunctionsTextarea) {
                        outputFunctionsTextarea.value = content;
                        alert('已載入檔案內容！');
                    }
                } catch (error) {
                    console.log('載入檔案失敗:', error);
                    alert('無法載入檔案內容。');
                }
            }
        }
        
        // 初始化界面
        initializeFromURL();
        setupFileHandling();
    </script>
</body>
</html> 