# 多輸出布林函數最小化工具

## 📋 項目簡介

這是一個基於 **Patrick Method** 演算法的多輸出布林函數最小化工具，專為邏輯電路設計和布林代數最佳化而開發。該工具支援多種輸入格式，能夠自動找到最佳的邏輯表達式，並通過硬體共享最小化總體成本。

## ✨ 功能特色

### 🎯 核心功能
- **多輸出最佳化**：同時處理多個布林函數，找到全域最佳解
- **Patrick Method 演算法**：實現完整的三階段最佳化流程
- **硬體共享最佳化**：自動識別可共享的 Prime Implicants，降低硬體成本
- **智能算法選擇**：根據問題規模自動選擇回溯搜索或窮舉搜索

### 📊 輸入模式
1. **Prime Implicants 模式**：直接輸入已知的 Prime Implicants
2. **Minterms 模式**：輸入 Minterms 和 Don't Care 項，自動生成 Prime Implicants

### 🔍 算法特色
- **三階段成本計算**：
  - Stage 1：基本 PI 成本計算
  - Stage 2：各函數獨立冗餘移除
  - Stage 3：Patrick 共享成本計算
- **智能剪枝**：多層剪枝策略提高搜索效率
- **成本最佳化**：支援單個 literal 和多個 literals 的不同成本計算

## 🚀 快速開始

### 系統需求
- 現代網頁瀏覽器（Chrome、Firefox、Safari、Edge）
- 支援 JavaScript ES6+

### 安裝與運行
1. 下載項目文件到本地
2. 用瀏覽器打開 `index.html`
3. 開始使用！

## 📖 使用指南

### 1. 設定變數
在「變數設定」欄位中輸入邏輯變數，用逗號分隔：
```
x,y,z
```
或
```
a,b,c,d
```

### 2. 選擇輸入模式

#### Prime Implicants 模式
適用於已知 Prime Implicants 的情況：

**範例輸入**：
```
函數 F1:
- PI1: 01-
- PI2: -11

函數 F2:
- PI1: 0-1
- PI2: 1-0
```

**輸出函數定義**（可選）：
```
F1 = Σm(2,3,6,7)
F2 = Σm(1,4,5)
```

#### Minterms 模式
適用於從 Minterms 開始設計的情況：

**範例輸入**：
```
函數 F1:
- Minterms: 2,3,6,7
- Don't Care: 1

函數 F2:
- Minterms: 1,4,5
- Don't Care: 0
```

### 3. 執行最佳化
點擊「執行多輸出最佳化」按鈕，系統將：
1. 解析輸入資料
2. 生成或處理 Prime Implicants
3. 執行 Patrick Method 演算法
4. 計算最佳共享方案
5. 顯示詳細結果

### 4. 結果解讀

#### 最佳化結果
```
🔹 解決方案:
F1 = x'z' + yz'
F2 = x'y + xy'

使用的PI: 01-, -11, 0-1, 1-0
共享成本: 18 個閘級
```

#### 成本分析
```
💰 成本分析
成本計算方式：每個項的成本 = 符號數量 + 1
例如：x'z' 有 2 個符號，成本為 2 + 1 = 3

個別最佳化總成本: 24
共享最佳化總成本: 18
💡 節省成本: 6 (25.0%)
```

## 🔧 技術實現

### 核心算法

#### Patrick Method 三階段流程
1. **Stage 1 - PI 生成與基本求解**：
   - 使用 Quine-McCluskey 方法生成 Prime Implicants
   - 建立覆蓋表 (Coverage Table)
   - 找出必要 Prime Implicants (Essential PIs)

2. **Stage 2 - 各函數獨立冗餘移除**：
   - 對每個函數獨立進行冗餘 PI 移除
   - 應用特殊優化規則（如用 y 取代 yz'+x'y）
   - 確保每個函數達到局部最佳

3. **Stage 3 - Patrick 共享成本計算**：
   - 計算跨函數的 PI 共享效益
   - 應用 Patrick 共享成本公式：`base_cost + usage_count - 1`
   - 找到全域最佳解

#### 成本計算公式
- **單個 literal**：成本 = 1
- **多個 literals**：成本 = literal_count + 1
- **共享 PI**：成本 = 基礎成本 + 使用次數 - 1

#### 算法選擇策略
- **PI 數量 ≤ 20**：使用窮舉搜索（三階段成本計算）
- **PI 數量 > 20**：使用回溯搜索（簡化成本計算）

### 技術架構

#### 前端 (index.html)
- **響應式設計**：支援各種螢幕尺寸
- **動態輸入界面**：支援多函數動態添加/移除
- **即時驗證**：輸入格式檢查和錯誤提示
- **結果視覺化**：清晰的結果展示和成本分析

#### 後端 (patrick-method-core.js)
- **模組化設計**：清晰的類別結構和方法分離
- **算法最佳化**：多層剪枝和智能搜索策略
- **錯誤處理**：完善的異常捕獲和處理機制
- **跨平台支援**：同時支援瀏覽器和 Node.js 環境

## 📊 範例案例

### 案例 1：三變數雙函數最佳化

**輸入**：
- 變數：`x,y,z`
- F1 = Σm(2,3,6,7)
- F2 = Σm(1,4,5)

**輸出**：
```
F1 = x'z' + yz'
F2 = x'y + xy'
共享成本: 18 個閘級
節省成本: 6 (25.0%)
```

### 案例 2：四變數三函數最佳化

**輸入**：
- 變數：`a,b,c,d`
- F1 = Σm(0,2,5,7,8,10,13,15)
- F2 = Σm(1,3,4,6,9,11,12,14)
- F3 = Σm(0,1,6,7,8,9,14,15)

**預期結果**：
- 自動識別可共享的 Prime Implicants
- 計算最佳共享方案
- 提供詳細的成本分析

## 🔍 算法詳解

### Quine-McCluskey 方法
1. **分組**：按照 1 的個數分組
2. **合併**：相鄰組間尋找可合併項
3. **迭代**：重複合併直到無法繼續
4. **篩選**：找出真正的 Prime Implicants

### Patrick Method 求解
1. **覆蓋表建立**：建立 PI 與 Minterm 的覆蓋關係
2. **必要 PI 識別**：找出覆蓋唯一 Minterm 的 PI
3. **最小覆蓋求解**：使用回溯或窮舉找最小成本覆蓋
4. **多函數最佳化**：考慮跨函數共享的全域最佳化

### 成本最佳化策略
1. **局部最佳化**：每個函數獨立最佳化
2. **全域最佳化**：考慮函數間共享效益
3. **剪枝策略**：多層剪枝提高搜索效率
4. **啟發式搜索**：智能選擇搜索路徑

## 🛠️ 開發資訊

### 項目結構
```
final/
├── index.html              # 主要網頁界面
├── patrick-method-core.js   # 核心算法實現
└── README.md               # 項目文檔
```

### 核心類別
- **PatrickMethod**：基礎 Patrick Method 算法類
- **MultipleOutputPatrick**：多輸出最佳化擴展類

### 主要方法
- `executeMultipleOutput()`：多輸出最佳化主入口
- `generateQuineMcCluskeyPIs()`：Quine-McCluskey PI 生成
- `solveJointPatrickMethod()`：聯合 Patrick Method 求解
- `calculateThreeStagesCost()`：三階段成本計算

## 📈 性能特色

### 算法效率
- **智能剪枝**：多層剪枝策略，大幅減少搜索空間
- **成本預估**：提前估算成本，避免無效搜索
- **記憶化**：緩存中間結果，避免重複計算

### 處理能力
- **小規模問題**（PI ≤ 20）：使用窮舉搜索，保證最佳解
- **大規模問題**（PI > 20）：使用回溯搜索，快速找到近似最佳解
- **多函數支援**：支援任意數量的輸出函數

## 🎓 教育價值

### 學習目標
- 理解 Patrick Method 演算法原理
- 掌握多輸出邏輯最小化技術
- 學習硬體共享最佳化策略
- 體驗算法設計和最佳化過程

### 適用課程
- 數位邏輯設計
- 計算機組織與結構
- 算法設計與分析
- 邏輯電路最佳化

## 🤝 貢獻指南

### 回報問題
如發現 bug 或有改進建議，請：
1. 詳細描述問題現象
2. 提供輸入資料和預期結果
3. 包含瀏覽器和系統資訊

### 功能建議
歡迎提出新功能建議：
- 新的輸入格式支援
- 算法效能改進
- 使用者界面優化
- 教學功能增強

## 📄 授權資訊

本項目為教育用途開發，遵循 MIT 授權條款。

## 🔗 相關資源

### 參考文獻
- Patrick, R. L. (1956). "A Generalized Algorithm for Finding a Minimal Set of Prime Implicants"
- Quine, W. V. (1952). "The Problem of Simplifying Truth Functions"
- McCluskey, E. J. (1956). "Minimization of Boolean Functions"

### 延伸閱讀
- 數位邏輯設計教科書
- 布林代數與邏輯最小化理論
- VLSI 設計最佳化技術

---

**開發團隊**：元智大學 電機系甲組大一B班 顏逢佐 個人開發  
**最後更新**：2024年12月  
**版本**：1.0.0 